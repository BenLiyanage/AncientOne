### This tells you whose turn it is and controls 

import pygame
import sprites
from sprites import AnimatedSprite, Actor
import GameBoard
from GameBoard import Board
import collision
from collision import PopBestPath, PathList

ATTACK="Attack"
MOVE="Move"

class Turn(object):
    def __init__(self, characters, board):

        self._canAttack=True
        self._canMove=True
        self._canSpecial1 = True
        self._canSpecial2 = True
        self._mode=[]#Modes include 'Attack', 'Move'
        self._characters= characters
        self._board=board
        
        self._initiativeThreshold=50#make this large, relative to speed.

        self._currentSprite=[]
        self._moves=[]#moves generated by CollisionFinder
        self._path=[]#path from the moves
        self._targetlist=[]


        
    def Mode(self):
        return self._mode
    def AttackMode(self):
        self._mode = ATTACK
    def TargetList(self, rangeMin, rangeMax):
        #print("targetlist called")
        targetlist=[]
        self._mode = ATTACK
        tile_x=self._currentSprite.tile_x
        tile_y=self._currentSprite.tile_y
        for actor in self._characters:
            actor_distance=abs(actor.tile_x-tile_x)+abs(actor.tile_y-tile_y)
            if actor_distance>=rangeMin and actor_distance <=rangeMax:
                self._board.HighlightTile(actor.tile_x, actor.tile_y, "images/blue_box.png")
                #print("highlighted", actor)
                targetlist.append(actor)
        self._targetlist = targetlist
                
    def MoveMode(self):
        self._mode = MOVE
        self._moves = PathList(self._board, self._currentSprite.tile_x,self._currentSprite.tile_y, self._currentSprite._Movement)
        #print(self._moves)
        self._board.DrawPossibleMoves(self._moves)
    def EndTurn(self):
        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._currentSprite._Initiative=0
        self._currentSprite=[]
        self._canAttack=True
        self._canMove=True
        self._canSpecial1 = True
        self._canSpecial2 = True
        self._mode=[]
        self._moves=[]#moves generated by CollisionFinder
        self._path=[]#path from the moves
        self._targetlist=[]
        self.Next()
        
        
        
    def Next(self):#When a player ends their turn it finds the next player up and returns that value
        print("Next Called")
        self._currentSprite=[]
        highestInitiative=0
        highestActor=[]#we could just use _currentSprite but this is nicer
        for actor in self._characters:      
            if actor._Initiative>highestInitiative:
                highestInitiative= actor._Initiative
                highestActor=actor
        while highestInitiative < self._initiativeThreshold:
            #first add a little to everyones initiative
            for actor in self._characters:
                actor._Initiative+=actor._Speed
            #then find the highest
            for actor in self._characters:      
                if actor._Initiative>highestInitiative:
                    highestInitiative= actor._Initiative
                    highestActor=actor
        self._currentSprite=highestActor
        self._board.PanCamera((self._currentSprite.tile_x + self._board._screenTileOffset_x)*self._board._tileSize, \
            (self._currentSprite.tile_y+ self._board._screenTileOffset_y)*self._board._tileSize)
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        return self._currentSprite

    #def Back(self): #back out of move or attack mode if you haven't already moved/attacked
    def Attack(self,target):
        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        self._currentSprite.Attack(target)
        
        print(self._currentSprite._Name, "attacked", target._Name)
        self._canAttack=False
        self._mode=[]
        #blot out the UI somehow

    def Move(self, tile_x, tile_y):
        #print("looking for a way to", tile_x, tile_y)
        if self._moves !=[]:
            self._path = PopBestPath(tile_x, tile_y, self._moves)
        #print(self._moves)
        
        
        if self._path == []:
            pass
        elif self._canMove==True: #player has selected a possible path
            
            self._board.ClearLayer(self._board._shadowLayer)
            self._currentSprite.MultiMove(self._path)
            self._board.HighlightTile(tile_x, tile_y, "images/ActiveShadow.png")
            self._canMove=False
            self._path=[]#just in case we reset
            self._moves=[]#again, just in case.
            self._mode=[]
        
        
    def CurrentSprite(self):
        return self._currentSprite



