# <This is the file that controls turn attacking and other functions related to game mechanics.>
# Copyright (C) <2012>  <Phong Le and Benjamin Liyanage>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import pygame
import random
import sprites
from sprites import AnimatedSprite, Actor
import GameBoard
from GameBoard import Board
import collision
from collision import PopBestPath, PathList, MovesArray, CollisionArray, TracePath

import AutoTurn
from AutoTurn import TurnAI, PortalAI, actorDist, dist

MOVE="Move"


#other forms of attack
ATTACK="Attack"
WHIRLWIND="Whirlwind"
CRIPPLESTRIKE="Cripple"
RANGED="Ranged"
SPECIAL="Special"
AOE="Fire Lion"
HEAL="Heal"

MOVE="Move"
CANCEL="Cancel"
WAIT="End Turn"

ATTACKLIST=[ATTACK, WHIRLWIND, CRIPPLESTRIKE, RANGED,SPECIAL,AOE, HEAL]

#alignments
FRIENDLY='Friendly'
HOSTILE='Hostile'
NEUTRAL = 'Neutral'

#Special Modes
LEVELUP = 'Level Up'

class Turn(object):
    def __init__(self, board):

        self._canAttack=True
        self._canMove=True

        self._mode=[]#Modes include 'Attack', 'Move'
        self._characters= board.Characters()
        self._board=board
        
        self._initiativeThreshold=100#make this large, relative to speed.

        self._currentSprite=[]
        self._currentActions=[]
        self._moves=[]#moves generated by CollisionFinder
        self._path=[]#path from the moves
        self._targetList=[]

        #these two are used to string together actions.
        self._MidAction = 0
        self._actionQueue = []

        ##Load UsefulSprite/Images
        self._DeathImageSet=sprites.load_sliced_sprites(64,64,'images/skeleton/skeleton_death.png')
        self._SkeletonImageSet = sprites.load_sliced_sprites(64, 64, 'images/skeleton/skeleton_walk.png')
        self._SkeletonAttackImageSet = sprites.load_sliced_sprites(64, 64, 'images/skeleton/skeleton_attack.png')
        self._PigImageSet = sprites.load_sliced_sprites(64, 64, 'images/pigman/pigman_walk.png')
        self._PigAttackImageSet = sprites.load_sliced_sprites(64, 64, 'images/pigman/pigman_walk.png')
        self._PortalImageSet = sprites.load_sliced_sprites(128,128,'images/magic/turtleshell_large.png')
        self._SpecialImageSet = sprites.load_sliced_sprites(64,96,'images/AncientOne_image.png')

        self._MageDeathImageSet=sprites.load_sliced_sprites(64,64,'images/mage/mage_death.png')
        self._MageImageSet = sprites.load_sliced_sprites(64, 64, 'images/mage/mage_walk.png')
        self._MageAttackImageSet = sprites.load_sliced_sprites(64, 64, 'images/mage/mage_spell.png')
        self._mageMinRange = 2
        self._mageMaxRange= 5


        self._LastActionTimer=0
        self._ActionDelay=700 #delay in ms between AI actions


        

                




        
    def CancelMode(self, highlight=True):
        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        if highlight:
            self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        self.Board().ChangeCursor("images/blue_box.png", 0, 0)
        self._moves=[]
        self._path=[]
        self._targetList=[]
        self._mode=[]
        if CANCEL in self._currentActions:
            self._currentActions.remove(CANCEL)
        if self._canMove:
            self._currentActions.append(MOVE)
        if self._canAttack:
            for action in ATTACKLIST:#adds back in attacks that you can still do
                if action in self.CurrentSprite().GetActionNames():
                    self._currentActions.append(action)
        elif self._canAttack == False:
            for action in ATTACKLIST:#adds back in attacks that you can still do
                if action in self.CurrentActions():
                    self._currentActions.remove(action)
    def EndTurn(self):


        #if you acted your initiative goes down a bit
        if self._canAttack==True and self._canMove==True:
            self._currentSprite._Initiative=25
        elif self._canAttack==True or self._canMove==True:
            self._currentSprite._Initiative=10
        else:
            self._currentSprite._Initiative=0
        
        self._canAttack=True
        self._canMove=True

        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        self.Board().ChangeCursor("images/blue_box.png", 0, 0)
        self._moves=[]
        self._path=[]
        self._targetList=[]
        self._mode=[]
        
        if self.CurrentSprite().LevelUp():
            #don't do anything else, the level up window will call self.Next()when it is good and ready
            print("Level UP!")
            self._mode=LEVELUP
            pass
        else:
            self._currentSprite=[]#this is a bit redundant since it is done in Next as well.
            self.Next()
        
        
    def Next(self):#When a player ends their turn it finds the next player up and returns that value
        #print("Next Called")
        
        #if self.CurrentSprite() !=[]:
        #    self.CurrentSprite()._Initiative=0 #resets initiative
        NewTurnSound = pygame.mixer.Sound("sound/blip2.wav")
        NewTurnSound.play()
        self._currentSprite=[]
        highestInitiative=0
        highestActor=[]#we could just use _currentSprite but this is nicer

        #first checks if anyone has a high enough initiative to go
        for actor in self._characters:      
            if actor._Initiative>highestInitiative:
                highestInitiative= actor._Initiative
                highestActor=actor
        #if not one has high enough initiative it adds speed to everyones initiative
        while highestInitiative < self._initiativeThreshold:
            #first add a little to everyones initiative
            for actor in self._characters:
                actor.Wait()
                #print(actor.Name(),'initiative increased to', actor.Initiative())
            #then find the highest
            for actor in self._characters:      
                if actor._Initiative>highestInitiative:
                    highestInitiative= actor._Initiative
                    highestActor=actor
   
        self._currentSprite=highestActor
        self._currentActions=self.CurrentSprite().GetActionNames()
        self._currentActions.remove(CANCEL)

        #if self._currentSprite.Alignment()==FRIENDLY:
        self._board.PanCamera((self._currentSprite.tile_x + self._board._screenTileOffset_x)*self._board._tileSize, \
            (self._currentSprite.tile_y+ self._board._screenTileOffset_y)*self._board._tileSize) 

        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")


        #Select the different types of AI
        if self._currentSprite.Alignment() == 'Friendly':
            #TurnAI(self)#only do this if you want them to fight each other
            return self.CurrentSprite()
        
        elif self.CurrentSprite().Name()=='Portal':
            PortalAI(self)
            return self.CurrentSprite()
        elif self.CurrentSprite().Name() == "Mage" or self.CurrentSprite().Name()=='Ancient One':
            TurnAI(self,self._mageMinRange,self._mageMaxRange)
        else:
            #print('Found a hostile')
            TurnAI(self, 1, 1)
            return self.CurrentSprite()

    
    def Move(self, tile_x, tile_y):
        #print("looking for a way to", tile_x, tile_y)
        if self._moves !=[] and self.Mode()==MOVE:
            #self._path = PopBestPath(tile_x, tile_y, self._moves)#removed for new path testing
            self._path = TracePath(self._moves, tile_x,tile_y)          

        
        
        if self._path == [] and self.Mode()==MOVE:
            pass
        elif self._canMove==True: #player has selected a possible path
            self._board.ClearLayer(self._board._shadowLayer)
            if CANCEL in self._currentActions:
                self._currentActions.remove(CANCEL)
 
            
  
            self._currentSprite.MultiMove(self._path)
            self._board.HighlightTile(tile_x, tile_y, "images/ActiveShadow.png")
            self._canMove=False

            self.CancelMode(highlight=False)

    def MoveMode(self):
        if self._canMove:
            self._mode = MOVE
            #self._moves = PathList(self._board, self._currentSprite.tile_x,self._currentSprite.tile_y, self._currentSprite._Movement)
            boundarySet= [{'x':self._currentSprite.tile_x,'y':self._currentSprite.tile_y, 'cost':0, 'previous_x':self._currentSprite.tile_x,'previous_y':self._currentSprite.tile_y }]
            self._moves= MovesArray(CollisionArray(self._board), boundarySet,[],self._currentSprite._Movement,0)
            #print(self._moves)
            #self._board.ClearLayer(self._board._shadowLayer)
            self._board.DrawPossibleMoves(self._moves)
            self._currentActions.append(CANCEL)
            self._currentActions.remove(MOVE)
            if self._canAttack:
                for action in ATTACKLIST:#adds back in attacks that you can still do
                    if action in self.CurrentSprite().GetActionNames():
                        self._currentActions.remove(action)



    def Mode(self):
        return self._mode

    def CurrentSprite(self):
        return self._currentSprite

    def CurrentActions(self):
        return self._currentActions

    def LevelUpActions(self): #returns self._currentActions to only have skills that can be leveled
        levelActions = self.CurrentSprite().GetActionNames()
        levelActions.remove(MOVE)
        levelActions.remove(CANCEL)
        levelActions.remove(WAIT)

        return levelActions

            
        
    def Characters(self):
        return self._characters
    def Board(self):
        return self._board

    def addQueue(self, actionName, closeOpponent ,Move):   #something like addQueue("Attack", ) would tell the currentSprite to attack the Actor in (5,13) 
        self._actionQueue.append((actionName,closeOpponent,Move))
    def Queue(self):
        return self._actionQueue
        

    def update(self, t):  #mostly for the AI turns.  checks if the character is animating
        if self.CurrentSprite().Animating():
            pass
        elif self.Queue() !=[] and t-self._LastActionTimer> self._ActionDelay:
            
            self.Queue().reverse()
            nextMove=self.Queue().pop()
            self.Queue().reverse()
            #print(nextMove, 'is begin performed')
            self.AIAction(nextMove)

            self._LastActionTimer=t
        self.CurrentActions().sort()

        
    def AIAction(self, action):
        #print('Action is Called')
        #an action is a list =('Attack' or 'Move' or 'Wait', a possible target (actor), and a move)
        #this is how the AI tells NPCs what to do.
        actiontype=action[0]
        actiontarget=action[1]
        actionmove=action[2]
        if actiontype=='Attack':
            self._canAttack=False
            if self.CurrentSprite().Name()=='Mage':
                self.TargetList(self._mageMinRange, self._mageMaxRange)
                self.Board().AnimatedParticleEffect(64,64,'images/magic/magic_snakebite_small.png',actiontarget.tile_x+.5, actiontarget.tile_y)
            else:
                self.TargetList(1,1)#we do this for now
            LaserSound = pygame.mixer.Sound("sound/laser.wav")
            LaserSound.play()
            
            self.CurrentSprite().Attack(actiontarget,int(1.5*self.CurrentSprite().Power())+self.CurrentSprite().Level()+random.randint(0,self.CurrentSprite().Power()))
        elif actiontype=='Move':
            self._canMove=False
            #print(actionmove[3])
            self._board.ClearLayer(self._board._shadowLayer)
            self._path = actionmove#PopBestPath(actionmove[0],actionmove[1], [actionmove])
            
            self._currentSprite.MultiMove(self._path)
        elif actiontype=='Wait':
            #print(self.CurrentSprite().Name(), 'is done with turn!')
            self.EndTurn()
        elif actiontype=='Tentacle':
            self.AOEAttack(actiontarget.tile_x, actiontarget.tile_y,imagepath='images/magic/torrentacle_large.png')
        else:
            pass
            #print('You should not be here. An action called', actiontype, 'was called.')
        
        

##Special Moves##
#these are all the special attacks mode are in two parts.
#The player enters a mode, i.e. "AOEmode" for an AOE attack which shades the targetable tiles and changed the cursor.
#the player then can make the attack

    
    def TargetList(self, rangeMin, rangeMax,Opponent=True):#finds targets valid targets in rage and enters them into targetList
        #print("targetlist called")
        targetlist=[]
        tile_x=self._currentSprite.tile_x
        tile_y=self._currentSprite.tile_y
        self._board.HighlightArea(tile_x,tile_y, rangeMin,rangeMax+1,"images/alpha_box.png")
        for actor in self._characters:
            actor_distance=abs(actor.tile_x-tile_x)+abs(actor.tile_y-tile_y)
            
            #Figure sout who to highlight
            if actor_distance>=rangeMin and actor_distance <=rangeMax:
                if actor.Alignment() != self._currentSprite.Alignment() and Opponent:
                    self._board.HighlightTile(actor.tile_x, actor.tile_y, "images/blue_box.png")
                    targetlist.append(actor)
                elif actor.Alignment()==self._currentSprite.Alignment() and Opponent==False:
                    self._board.HighlightTile(actor.tile_x, actor.tile_y, "images/blue_box.png")
                    targetlist.append(actor)
        self._targetList = targetlist

    def ActionMode(self, action):#finds the attack enters the right mode
        if self._currentSprite._path ==[] and self._currentSprite._MidAnimation ==0 and self._canAttack:
            self._mode = action
            if action==ATTACK:
                #print('action is attack')
                self.TargetList(1,1)#we do this for now
                self._currentActions.remove(ATTACK)
                self._currentActions.remove(WHIRLWIND)
            elif action ==WHIRLWIND:
                self._currentActions.remove(ATTACK)
                self._currentActions.remove(WHIRLWIND)
                self.Whirlwind()

            elif action == AOE:
                self.AOEMode(AOE, 4)
                self._currentActions.remove(AOE)
                self._currentActions.remove(HEAL)
            elif action == HEAL:
                self.AOEMode(HEAL,2)
                #self.TargetList(0,2, Opponent=False)
                self._currentActions.remove(AOE)
                self._currentActions.remove(HEAL)
            elif action == RANGED or self.Mode()==CRIPPLESTRIKE:
                self.TargetList(3,7)
                self._currentActions.remove(RANGED)
                self._currentActions.remove(CRIPPLESTRIKE)
            else:
                pass
                #print('Action', action, 'not recognized.')
            if CANCEL not in self._currentActions and action !=WHIRLWIND:
                self._currentActions.append(CANCEL)#you can cancel out of any action but whirlwind
            if self._canMove:
                self._currentActions.remove(MOVE)
                
    def Attack(self,target):#all purpose attack, used for both ranged and melee attacks
        if target in self._targetList:
            self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
            self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
            if self.Mode()==ATTACK: 
                self._currentSprite.Attack(target, int(1.5*self.CurrentSprite().Power())+3*self.CurrentSprite().ActionLevel(ATTACK)+random.randint(0,self.CurrentSprite().Power()))

            elif self.Mode()==RANGED:
                self._currentSprite.Attack(target, self.CurrentSprite().Power()+3*self.CurrentSprite().ActionLevel(RANGED)+random.randint(0,self.CurrentSprite().Power()))

            elif self.Mode()==CRIPPLESTRIKE:
                self._currentSprite.Attack(target, self.CurrentSprite().Power()+2*self.CurrentSprite().ActionLevel(RANGED)+random.randint(0,self.CurrentSprite().Power()))
                target._Initiative -= 10+ 5*self.CurrentSprite().ActionLevel(CRIPPLESTRIKE)

                if target._Initiative <0:
                    target._Initiative = 0
            else:
                self._currentSprite.Attack(target, self.CurrentSprite().Power()+random.randint(0,self.CurrentSprite().Power()))
            if CANCEL in self._currentActions:
                self._currentActions.remove(CANCEL)

            self._canAttack=False
            self.CancelMode()

    def HealAction(self, tile_x, tile_y):

            if dist(self.CurrentSprite().tile_x,self.CurrentSprite().tile_y, tile_x,tile_y)<=2:
                HitAnyone=False
                for actor in self.Characters():
                    #print(actor.tile_x,actor.tile_y)
                    if dist(actor.tile_x, actor.tile_y, tile_x, tile_y) <=1 and actor.Health()<actor.MaxHealth():
                        HitAnyone=True
                        self.CurrentSprite().Heal(actor, 3*self.CurrentSprite().ActionLevel(HEAL)+random.randint(int(self.CurrentSprite().Power()),self.CurrentSprite().Power()))
                if HitAnyone:#check if anyone was damaged, if not then don't do anything
                    self._board.ClearLayer(self._board._shadowLayer)
                    HealSound = pygame.mixer.Sound("sound/Heal.wav")
                    HealSound.play()
                    #self.Board().AnimatedParticleEffect(128,128,imagepath,tile_x, tile_y)
                    self._canAttack=False               

                    self.CancelMode()
                    if CANCEL in self._currentActions:
                        self._currentActions.remove(CANCEL)

    def AOEMode(self, AOEtype, AOErange):
        if self._canAttack:
            self._mode=AOEtype
            
            self._board.HighlightArea(self._currentSprite.tile_x, self._currentSprite.tile_y, 0, AOErange+1,'images/alpha_box.png')            
            self.Board().ChangeCursor("images/area01.png", -1, -1)

            if CANCEL not in self._currentActions:
                self._currentActions.append(CANCEL)

            
    def AOEAttack(self,tile_x,tile_y, imagepath = 'images/magic/AOE_firelion.png'):#This is also known as Fire Lion!

        if dist(self.CurrentSprite().tile_x,self.CurrentSprite().tile_y, tile_x,tile_y)<=4:
            
            #print(tile_x+self.Board()._camTile_x,tile_y+self.Board()._camTile_y)
            HitAnyone=False
            for actor in self.Characters():
                #print(actor.tile_x,actor.tile_y)
                if dist(actor.tile_x, actor.tile_y, tile_x, tile_y) <=1:
                    HitAnyone=True
                    self._currentSprite.Attack(actor,2*self.CurrentSprite().Power()+2*self.CurrentSprite().ActionLevel(AOE)+random.randint(0,self.CurrentSprite().Power()))
                    #print(self._currentSprite._Name, "attacked", actor._Name, 'with', AOE)
            if HitAnyone:#check if anyone was damaged, if not then don't do anything
                self._board.ClearLayer(self._board._shadowLayer)
                AttackSound = pygame.mixer.Sound("sound/explosion.wav")
                AttackSound.play()
                self.Board().AnimatedParticleEffect(128,128,imagepath,tile_x, tile_y)
                self._canAttack=False               

                self.CancelMode()
                if CANCEL in self._currentActions:
                    self._currentActions.remove(CANCEL)
    
        else:
            pass
            #print("Target Tile is out of Range.")

    def Whirlwind(self):#attacks all players (hostile or friendly) in adjacent spa
        HitAnyone=False
        
        for actor in self.Characters():
            if dist(actor.tile_x, actor.tile_y, self.CurrentSprite().tile_x, self.CurrentSprite().tile_y) <=2 and actor.Alignment() != self.CurrentSprite().Alignment():
                self._currentSprite.Attack(actor,self.CurrentSprite().Power()+3*self.CurrentSprite().ActionLevel(WHIRLWIND)+random.randint(0,self.CurrentSprite().Power()))
                HitAnyone=True
        if HitAnyone:
            AttackSound = pygame.mixer.Sound("sound/explosion.wav")
            AttackSound.play()

        self._canAttack=False

        self.CancelMode()

                

    def SpawnSkeleton(self, board_x, board_y, level=1):#since this should only happen with the bad guys we will not have a mode

        SkeletonSprite = Actor((board_x-.5)*self.Board()._tileSize, (board_y-1)*self.Board()._tileSize, \
            self._SkeletonImageSet[0], self._SkeletonImageSet[1], self._SkeletonImageSet[2], self._SkeletonImageSet[3], \
            self._DeathImageSet[0], self._SkeletonAttackImageSet[0], self._SkeletonAttackImageSet[1], self._SkeletonAttackImageSet[2], self._SkeletonAttackImageSet[3], \
            "Skeleton", HOSTILE ,4, 3, 3, 4, random.randint(9,12))
        SkeletonSprite.ForceLevel(level)
        #SkeletonSprite.RegisterAction("Slash","The skeleton lashes out at the target", self.Attack, self._SkeletonImageSet[3])
        self.Characters().add(SkeletonSprite)

    def SpawnMage(self, board_x, board_y, level=1):
        MageSprite = Actor((board_x-.5)*self.Board()._tileSize, (board_y-1)*self.Board()._tileSize, self._MageImageSet[0], self._MageImageSet[1], self._MageImageSet[2], self._MageImageSet[3], \
            self._MageDeathImageSet[0], self._MageAttackImageSet[0], self._MageAttackImageSet[1], self._MageAttackImageSet[2], self._MageAttackImageSet[3], \
            "Mage", HOSTILE ,4, 3, 3, 4, random.randint(9,12))
        MageSprite.ForceLevel(level)
        self.Characters().add(MageSprite)

    def SpawnPortal(self, board_x, board_y, level =1):
        PortalSprite = Actor((board_x-1.25)*self.Board()._tileSize, (board_y-1.4)*self.Board()._tileSize, \
            self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], \
            self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], \
            "Portal", HOSTILE ,3, 4, 3, 0, random.randint(18,21), x=-1.25*self.Board()._tileSize, y=-1.4*self.Board()._tileSize)
        PortalSprite.ForceLevel(level)
        PortalSprite.RegisterAction("Spawn","Spawn a skeleton from the Abyss", [],[])
        PortalSprite.RegisterAction(AOE, 'The character conjures Feline Flames!', [],[])
        self.Characters().add(PortalSprite)

    def SpawnSpecial(self, board_x, board_y, level =3):
        SpecialSprite = Actor((board_x-.5-0)*self.Board()._tileSize, (board_y-2)*self.Board()._tileSize, \
            self._SpecialImageSet[0], self._SpecialImageSet[1], self._SpecialImageSet[2], self._SpecialImageSet[3], \
            self._SpecialImageSet[0], self._SpecialImageSet[0], self._SpecialImageSet[1], self._SpecialImageSet[2], self._SpecialImageSet[3], \
            "Ancient One", HOSTILE ,10, 10, 3, 10, random.randint(28,31), x=-.4*self.Board()._tileSize, y=-1*self.Board()._tileSize)
        SpecialSprite.ForceLevel(level)
        SpecialSprite.RegisterAction("Spawn","Spawn a skeleton from the Abyss", [],[])
        SpecialSprite.RegisterAction(AOE, 'The character conjures Feline Flames!', [],[])
        self.Characters().add(SpecialSprite)


    def SpawnPig(self, board_x, board_y, level=1):#since this should only happen with the bad guys we will not have a mode
        PigSprite = Actor((board_x-.5)*self.Board()._tileSize, (board_y-1)*self.Board()._tileSize, \
            self._PigImageSet[0], self._PigImageSet[1], self._PigImageSet[2], self._PigImageSet[3], \
            self._DeathImageSet[0], self._PigAttackImageSet[0], self._PigAttackImageSet[1], self._PigAttackImageSet[2], self._PigAttackImageSet[3], \
            "Pigman", HOSTILE ,5, 4, 4, 6, random.randint(12,15))
        PigSprite.ForceLevel(level)
        #SkeletonSprite.RegisterAction("Slash","The skeleton lashes out at the target", self.Attack, self._SkeletonImageSet[3])
        self.Characters().add(PigSprite)
    #def VampiricStrike(actor,target):# a special attack that also heals you.

    def SpawnRandomEnemy(self,board_x,board_y, spawnlevel):
        randomRoll=random.randint(0,2)
        if randomRoll==0:
            self.SpawnSkeleton(board_x,board_y,level = spawnlevel)
        elif randomRoll==1:
            self.SpawnMage(board_x,board_y,level=spawnlevel)
        elif randomRoll==2:
            self.SpawnPig(board_x,board_y,level = spawnlevel)  

#def PassiveHeal(actor):

              
                               




