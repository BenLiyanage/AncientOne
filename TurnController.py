### This tells you whose turn it is and controls 

import pygame
import random
import sprites
from sprites import AnimatedSprite, Actor
import GameBoard
from GameBoard import Board
import collision
from collision import PopBestPath, PathList

import AutoTurn
from AutoTurn import TurnAI, PortalAI, actorDist, dist

MOVE="Move"


#other forms of attack
ATTACK="Attack"
WHIRLWIND="Whirlwind"
CRIPPLESTRIKE="Cripple"
RANGED="Ranged"
SPECIAL="Special"
AOE="Fire Lion"
HEAL="Heal"

#alignments
FRIENDLY='Friendly'
HOSTILE='Hostile'
NEUTRAL = 'Neutral'

#Special Modes
LEVELUP = 'Level Up'

class Turn(object):
    def __init__(self, board):

        self._canAttack=True
        self._canMove=True

        self._mode=[]#Modes include 'Attack', 'Move'
        self._characters= board.Characters()
        self._board=board
        
        self._initiativeThreshold=100#make this large, relative to speed.

        self._currentSprite=[]
        self._currentActions=[]
        self._moves=[]#moves generated by CollisionFinder
        self._path=[]#path from the moves
        self._targetList=[]

        #these two are used to string together actions.
        self._MidAction = 0
        self._actionQueue = []

        ##Load UsefulSprite/Images
        self._DeathImageSet=sprites.load_sliced_sprites(64,64,'images/skeleton_death.png')
        self._SkeletonImageSet = sprites.load_sliced_sprites(64, 64, 'images/skeleton/skeleton_walk.png')
        self._SkeletonAttackImageSet = sprites.load_sliced_sprites(64, 64, 'images/skeleton/skeleton_attack.png')
        self._PigImageSet = sprites.load_sliced_sprites(128, 128, 'images/magic/turtleshell_large.png')
        self._PortalImageSet = sprites.load_sliced_sprites(128,128,'images/magic/turtleshell_large.png')

        self._MageDeathImageSet=sprites.load_sliced_sprites(64,64,'images/mage/mage_death.png')
        self._MageImageSet = sprites.load_sliced_sprites(64, 64, 'images/mage/mage_walk.png')
        self._MageAttackImageSet = sprites.load_sliced_sprites(64, 64, 'images/mage/mage_spell.png')
        self._MageMinRange = 2
        self._MageMaxRange=5

        self._LastActionTimer=0
        self._ActionDelay=700 #delay in ms between AI actions

        
    def Mode(self):
        return self._mode

                
    def MoveMode(self):
        if self._canMove:
            self._mode = MOVE
            self._moves = PathList(self._board, self._currentSprite.tile_x,self._currentSprite.tile_y, self._currentSprite._Movement)
            #print(self._moves)
            self._board.DrawPossibleMoves(self._moves)


        
    def CancelMode(self):
        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        self.Board().ChangeCursor("images/blue_box.png", 0, 0)
        self._moves=[]
        self._path=[]
        self._targetList=[]
        self._mode=[]
        #if len(self.CurrentActions()) <=2:
        #    print("The endTurn is nigh")
        #    self.EndTurn()
        
    def EndTurn(self):


        #if you acted your initiative goes down a bit
        if self._canAttack==True and self._canMove==True:
            self._currentSprite._Initiative=25
        elif self._canAttack==True or self._canMove==True:
            self._currentSprite._Initiative=10
        else:
            self._currentSprite._Initiative=0
        
        self._canAttack=True
        self._canMove=True

        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
        self.Board().ChangeCursor("images/blue_box.png", 0, 0)
        self._moves=[]
        self._path=[]
        self._targetList=[]
        self._mode=[]
        
        if self.CurrentSprite().LevelUp():
            #don't do anything else, the level up window will call self.Next()when it is good and ready
            print("Level UP!")
            self._mode=LEVELUP
            pass
        else:
            self._currentSprite=[]#this is a bit redundant since it is done in Next as well.
            self.Next()
        
        
    def Next(self):#When a player ends their turn it finds the next player up and returns that value
        #print("Next Called")
        
        #if self.CurrentSprite() !=[]:
        #    self.CurrentSprite()._Initiative=0 #resets initiative
        self._currentSprite=[]
        highestInitiative=0
        highestActor=[]#we could just use _currentSprite but this is nicer

        #first checks if anyone has a high enough initiative to go
        for actor in self._characters:      
            if actor._Initiative>highestInitiative:
                highestInitiative= actor._Initiative
                highestActor=actor
        #if not one has high enough initiative it adds speed to everyones initiative
        while highestInitiative < self._initiativeThreshold:
            #first add a little to everyones initiative
            for actor in self._characters:
                actor.Wait()
                #print(actor.Name(),'initiative increased to', actor.Initiative())
            #then find the highest
            for actor in self._characters:      
                if actor._Initiative>highestInitiative:
                    highestInitiative= actor._Initiative
                    highestActor=actor
   
        self._currentSprite=highestActor
        self._currentActions=self.CurrentSprite().GetActionNames()
        if self._currentSprite.Alignment==FRIENDLY:
            self._board.PanCamera((self._currentSprite.tile_x + self._board._screenTileOffset_x)*self._board._tileSize, \
                (self._currentSprite.tile_y+ self._board._screenTileOffset_y)*self._board._tileSize) 

        self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
        self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")


        #Select the different types of AI
        if self._currentSprite.Alignment() == 'Friendly':
            #TurnAI(self)#only do this if you want them to fight each other
            return self.CurrentSprite()
        
        elif self.CurrentSprite().Name()=='Portal':
            PortalAI(self)
            return self.CurrentSprite()
        elif self.CurrentSprite().Name() == "Mage":
            TurnAI(self,2,5)
        else:
            #print('Found a hostile')
            TurnAI(self, 1, 1)
            return self.CurrentSprite()

    
    def Move(self, tile_x, tile_y):
        #print("looking for a way to", tile_x, tile_y)
        if self._moves !=[]:
            self._path = PopBestPath(tile_x, tile_y, self._moves)
        #print(self._moves)
        
        
        if self._path == []:
            pass
        elif self._canMove==True: #player has selected a possible path
            
            self._board.ClearLayer(self._board._shadowLayer)
            self._currentSprite.MultiMove(self._path)
            self._board.HighlightTile(tile_x, tile_y, "images/ActiveShadow.png")
            self._canMove=False
            self._path=[]#just in case we reset
            self._moves=[]#again, just in case.
            self._mode=[]
            self._currentActions.remove(MOVE)


    def Mode(self):
        return self._mode

    def CurrentSprite(self):
        return self._currentSprite

    def CurrentActions(self):
        return self._currentActions
    def Characters(self):
        return self._characters
    def Board(self):
        return self._board

    def addQueue(self, actionName, closeOpponent ,Move):   #something like addQueue("Attack", ) would tell the currentSprite to attack the Actor in (5,13) 
        self._actionQueue.append((actionName,closeOpponent,Move))
    def Queue(self):
        return self._actionQueue
        

    def update(self, t):  #mostly for the AI turns.  checks if the character is animating
        if self.CurrentSprite().Animating():
            pass
        elif self.Queue() !=[] and t-self._LastActionTimer> self._ActionDelay:
            
            self.Queue().reverse()
            nextMove=self.Queue().pop()
            self.Queue().reverse()
            #print(nextMove, 'is begin performed')
            self.AIAction(nextMove)

            self._LastActionTimer=t

        
    def AIAction(self, action):
        #print('Action is Called')
        #an action is a list =('Attack' or 'Move' or 'Wait', a possible target (actor), and a move)
        #this is how the AI tells NPCs what to do.
        actiontype=action[0]
        actiontarget=action[1]
        actionmove=action[2]
        if actiontype=='Attack':
            self._canAttack=False
            if self.CurrentSprite().Name()=='Mage':
                self.TargetList(self._MageMinRange, self._MageMaxRange)
                self.Board().AnimatedParticleEffect(64,64,'images/magic/magic_snakebite_small.png',actiontarget.tile_x+.5, actiontarget.tile_y)
            else:
                self.TargetList(1,1)#we do this for now
            LaserSound = pygame.mixer.Sound("sound/laser.wav")
            LaserSound.play()
            self.CurrentSprite().Attack(actiontarget,self.CurrentSprite().Power())
        elif actiontype=='Move':
            self._canMove=False
            #print(actionmove[3])
            self._board.ClearLayer(self._board._shadowLayer)
            self._path = PopBestPath(actionmove[0],actionmove[1], [actionmove])
            self._currentSprite.MultiMove(self._path)
        elif actiontype=='Wait':
            #print(self.CurrentSprite().Name(), 'is done with turn!')
            self.EndTurn()
        else:
            print('You should not be here. An action called', actiontype, 'was called.')
        
        

##Special Moves##
#these are all the special attacks mode are in two parts.
#The player enters a mode, i.e. "AOEmode" for an AOE attack which shades the targetable tiles and changed the cursor.
#the player then can make the attack

    
    def TargetList(self, rangeMin, rangeMax,Opponent=True):#finds targets valid targets in rage and enters them into targetList
        #print("targetlist called")
        targetlist=[]
        tile_x=self._currentSprite.tile_x
        tile_y=self._currentSprite.tile_y
        self._board.HighlightArea(tile_x,tile_y, rangeMin,rangeMax+1,"images/alpha_box.png")
        for actor in self._characters:
            actor_distance=abs(actor.tile_x-tile_x)+abs(actor.tile_y-tile_y)
            
            #Figure sout who to highlight
            if actor_distance>=rangeMin and actor_distance <=rangeMax:
                if actor.Alignment() != self._currentSprite.Alignment() and Opponent:
                    self._board.HighlightTile(actor.tile_x, actor.tile_y, "images/blue_box.png")
                    targetlist.append(actor)
                elif actor.Alignment()==self._currentSprite.Alignment() and Opponent==False:
                    self._board.HighlightTile(actor.tile_x, actor.tile_y, "images/blue_box.png")
                    targetlist.append(actor)
        self._targetList = targetlist

    def ActionMode(self, action):#finds the attack enters the right mode
        if self._currentSprite._path ==[] and self._currentSprite._MidAnimation ==0 and self._canAttack:
            self._mode = action
            if action==ATTACK:
                #print('action is attack')
                self.TargetList(1,1)#we do this for now
            elif action == AOE:
                self.AOEMode()
            elif action == RANGED or self.Mode()==CRIPPLESTRIKE:
                self.TargetList(3,7)
            elif action ==WHIRLWIND:
                self.Whirlwind()
            elif action == HEAL:
                self.TargetList(0,2, Opponent=False)
            else:
                print('Action', action, 'not recognized.')
                
    def Attack(self,target):#all purpose attack, used for both ranged and melee attacks
        if target in self._targetList:
            self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
            self._board.HighlightTile(self._currentSprite.tile_x, self._currentSprite.tile_y, "images/ActiveShadow.png")
            if self.Mode()==ATTACK: 
                self._currentSprite.Attack(target, self.CurrentSprite().Power()+2*self.CurrentSprite().ActionLevel(ATTACK))
                self._currentActions.remove(ATTACK)
                self._currentActions.remove(WHIRLWIND)
            elif self.Mode()==RANGED:
                self._currentSprite.Attack(target, self.CurrentSprite().Power()+2*self.CurrentSprite().ActionLevel(RANGED))
                self._currentActions.remove(CRIPPLESTRIKE)
                self._currentActions.remove(RANGED)
            elif self.Mode()==CRIPPLESTRIKE:
                self._currentSprite.Attack(target, self.CurrentSprite().Power())#+2*self.CurrentSprite().ActionLevel(RANGED))
                target._Initiative -= 3*self.CurrentSprite().ActionLevel(CRIPPLESTRIKE)
                self._currentActions.remove(CRIPPLESTRIKE)
                self._currentActions.remove(RANGED)
                if target._Initiative <0:
                    target._Initiative = 0
            else:
                self._currentSprite.Attack(target, self.CurrentSprite().Power())
            self._canAttack=False
            self.CancelMode()

    def HealAction(self,target):
        if target in self._targetList:
            self._board.ClearLayer(self._board._shadowLayer)#clears off any shadow junk
            self.CurrentSprite().Heal(target, self.CurrentSprite().ActionLevel(HEAL))
            HealSound = pygame.mixer.Sound("sound/Heal.wav")
            HealSound.play()
            self._currentActions.remove(HEAL)
            self._currentActions.remove(AOE)
            
            self._canAttack=False
            self.CancelMode()

    def AOEMode(self):
        if self._canAttack:
            self._mode=AOE
            specialRange=4
            self._board.HighlightArea(self._currentSprite.tile_x, self._currentSprite.tile_y, 0, specialRange,'images/alpha_box.png')            
            self.Board().ChangeCursor("images/area01.png", -1, -1)
            
    def AOEAttack(self,tile_x,tile_y):#This is also known as Fire Lion!
        board_x, board_y =tile_x+self.Board()._camTile_x, tile_y+self.Board()._camTile_y
        if dist(self.CurrentSprite().tile_x,self.CurrentSprite().tile_y, board_x,board_y)<=3:
            
            #print(tile_x+self.Board()._camTile_x,tile_y+self.Board()._camTile_y)
            HitAnyone=False
            for actor in self.Characters():
                #print(actor.tile_x,actor.tile_y)
                if dist(actor.tile_x, actor.tile_y, board_x, board_y) <=1:
                    HitAnyone=True
                    self._currentSprite.Attack(actor,self.CurrentSprite().Power()+2*self.CurrentSprite().ActionLevel(AOE))
                    print(self._currentSprite._Name, "attacked", actor._Name, 'with', AOE)
            if HitAnyone:#check if anyone was damaged, if not then don't do anything
                self._board.ClearLayer(self._board._shadowLayer)
                AttackSound = pygame.mixer.Sound("sound/explosion.wav")
                AttackSound.play()
                self.Board().AnimatedParticleEffect(128,128,'images/magic/AOE_firelion.png',board_x, board_y)
                self._canAttack=False               
                self._currentActions.remove(HEAL)
                self._currentActions.remove(AOE)
                self.CancelMode()
        else:
            print("Target Tile is out of Range.")

    def SpawnSkeleton(self, board_x, board_y):#since this should only happen with the bad guys we will not have a mode

        SkeletonSprite = Actor((board_x-.5)*self.Board()._tileSize, (board_y-1)*self.Board()._tileSize, \
            self._SkeletonImageSet[0], self._SkeletonImageSet[1], self._SkeletonImageSet[2], self._SkeletonImageSet[3], \
            self._DeathImageSet[0], self._SkeletonAttackImageSet[0], self._SkeletonAttackImageSet[1], self._SkeletonAttackImageSet[2], self._SkeletonAttackImageSet[3], \
            "Skeleton", HOSTILE ,4, 1, 3, 4, random.randint(9,14))
        #SkeletonSprite.RegisterAction("Slash","The skeleton lashes out at the target", self.Attack, self._SkeletonImageSet[3])
        self.Characters().add(SkeletonSprite)

    def SpawnMage(self, board_x, board_y):
        MageSprite = Actor((board_x-.5)*self.Board()._tileSize, (board_y-1)*self.Board()._tileSize, self._MageImageSet[0], self._MageImageSet[1], self._MageImageSet[2], self._MageImageSet[3], \
            self._MageDeathImageSet[0], self._MageAttackImageSet[0], self._MageAttackImageSet[1], self._MageAttackImageSet[2], self._MageAttackImageSet[3], \
            "Mage", HOSTILE ,3, 3, 4, 4, random.randint(8,11))
        self.Characters().add(MageSprite)

    def SpawnPortal(self, board_x, board_y):
        PortalSprite = Actor((board_x-1.25)*self.Board()._tileSize, (board_y-1.4)*self.Board()._tileSize, \
            self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], \
            self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], self._PortalImageSet[0], \
            "Portal", HOSTILE ,0, 2, 2, 0, random.randint(11,16), x=-1.25*self.Board()._tileSize, y=-1.4*self.Board()._tileSize)
        PortalSprite.RegisterAction("Spawn","Spawn a skeleton from the Abyss", [],[])
        self.Characters().add(PortalSprite)
    #def VampiricStrike(actor,target):# a special attack that also heals you.

#def PassiveHeal(actor):

    def Whirlwind(self):#attacks all players (hostile or friendly) in adjacent spa
        HitAnyone=False
        for actor in self.Characters():
            if dist(actor.tile_x, actor.tile_y, self.CurrentSprite().tile_x, self.CurrentSprite().tile_y) ==1:# and actor.Alignment() != self.CurrentSprite().Alignment():
                self._currentSprite.Attack(actor,self.CurrentSprite().Power()+self.CurrentSprite().ActionLevel(WHIRLWIND))
            if HitAnyone:                
                AttackSound = pygame.mixer.Sound("sound/explosion.wav")
                AttackSound.play()
                self._canAttack=False
                self.CancelMode()                  
                               




